// Generated by CoffeeScript 1.9.1
(function() {
  var Cache, Klass, deepFreeze, deepMerge,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  deepFreeze = require('./util/deep_freeze');

  deepMerge = require('./util/deep_merge');

  Cache = require('./cache');

  module.exports = {
    Klass: Klass = (function() {
      function Klass() {}

      return Klass;

    })(),
    create: function(inputData, onChange, historySize) {
      var Cursor, batched, cache, data, redo, redos, undo, undos, update;
      if (historySize == null) {
        historySize = 100;
      }
      cache = new Cache;
      data = deepFreeze(inputData);
      batched = false;
      undos = [];
      redos = [];
      Cursor = (function(superClass) {
        extend(Cursor, superClass);

        function Cursor(path1) {
          this.path = path1 != null ? path1 : [];
        }

        Cursor.prototype.cursor = function(path) {
          var cached, cursor, fullPath;
          if (path == null) {
            path = [];
          }
          fullPath = this.path.concat(path);
          if ((cached = cache.get(fullPath)) != null) {
            return cached;
          }
          cursor = new Cursor(fullPath);
          cache.store(cursor);
          return cursor;
        };

        Cursor.prototype.get = function(path) {
          var i, key, len, ref, target;
          if (path == null) {
            path = [];
          }
          target = data;
          ref = this.path.concat(path);
          for (i = 0, len = ref.length; i < len; i++) {
            key = ref[i];
            target = target[key];
            if (target == null) {
              return void 0;
            }
          }
          return target;
        };

        Cursor.prototype.modifyAt = function(path, modifier, silent) {
          var fullPath, i, k, key, len, newData, ref, ref1, target, updated, v;
          fullPath = this.path.concat(path);
          newData = target = {};
          for (k in data) {
            v = data[k];
            target[k] = v;
          }
          ref = fullPath.slice(0, -1);
          for (i = 0, len = ref.length; i < len; i++) {
            key = ref[i];
            updated = Array.isArray(target[key]) ? [] : {};
            ref1 = target[key];
            for (k in ref1) {
              v = ref1[k];
              updated[k] = v;
            }
            target[key] = updated;
            Object.freeze(target);
            target = target[key];
          }
          modifier(target, fullPath.slice(-1));
          Object.freeze(target);
          cache.clearPath(fullPath);
          return update(newData, silent);
        };

        Cursor.prototype.set = function(path, value, silent) {
          if (silent == null) {
            silent = false;
          }
          if (this.path.length > 0 || path.length > 0) {
            return this.modifyAt(path, function(target, key) {
              return target[key] = deepFreeze(value);
            }, silent);
          } else {
            return update(value, silent);
          }
        };

        Cursor.prototype["delete"] = function(path, silent) {
          if (silent == null) {
            silent = false;
          }
          if (this.path.length > 0 || path.length > 0) {
            return this.modifyAt(path, function(target, key) {
              return delete target[key];
            }, silent);
          } else {
            return update(void 0, silent);
          }
        };

        Cursor.prototype.merge = function(data, silent) {
          if (silent == null) {
            silent = false;
          }
          cache.clearObject(data);
          return update(deepMerge(this.get(), deepFreeze(data)), silent);
        };

        Cursor.prototype.bind = function(path, pre) {
          return (function(_this) {
            return function(v, silent) {
              return _this.set(path, (pre ? pre(v) : v), silent);
            };
          })(this);
        };

        Cursor.prototype.has = function(path) {
          return this.get(path) != null;
        };

        Cursor.prototype.batched = function(cb, silent) {
          if (silent == null) {
            silent = false;
          }
          batched = true;
          cb();
          batched = false;
          return update(data, silent);
        };

        Cursor.prototype.shallowMerge = function(data) {
          return this.batched((function(_this) {
            return function() {
              var k, results, v;
              results = [];
              for (k in data) {
                v = data[k];
                results.push(_this.set([k], v));
              }
              return results;
            };
          })(this));
        };

        return Cursor;

      })(module.exports.Klass);
      undo = function() {
        if (!(undos.length > 0)) {
          return;
        }
        redos.push(data);
        if (redos.length > historySize) {
          redos.shift();
        }
        data = undos.pop();
        return onChange(new Cursor(), undo, redo);
      };
      redo = function() {
        if (!(redos.length > 0)) {
          return;
        }
        undos.push(data);
        if (undos.length > historySize) {
          undos.shift();
        }
        data = redos.pop();
        return onChange(new Cursor(), undo, redo);
      };
      update = function(newData, silent) {
        if (silent == null) {
          silent = false;
        }
        if (!(silent || batched)) {
          undos.push(data);
          if (undos.length > historySize) {
            undos.shift();
          }
        }
        data = newData;
        if (!batched) {
          return onChange(new Cursor(), undo, redo);
        }
      };
      return onChange(new Cursor(), undo, redo);
    }
  };

}).call(this);
